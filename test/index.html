<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BitDrop Comprehensive Test Suite</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: #0d1117; 
            color: #c9d1d9; 
            padding: 20px; 
            text-align: center; 
        }
        h1 { color: #58a6ff; margin-bottom: 5px; }
        p { color: #8b949e; margin-bottom: 20px; }

        .container { 
            max-width: 1000px; 
            margin: 0 auto; 
            background: #161b22; 
            padding: 30px; 
            border-radius: 10px; 
            border: 1px solid #30363d; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* Grid for 4 Methods */
        .methods-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .method-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .method-title {
            color: #58a6ff;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 14px;
        }

        .original-preview {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #30363d;
        }

        img, canvas {
            max-width: 100%;
            height: auto;
            max-height: 200px; /* Thoda chota kiya taaki sab dikhe */
            border: 1px solid #30363d;
            display: block;
            margin: 0 auto;
        }

        .status { 
            font-size: 12px; 
            font-weight: bold; 
            margin-top: 10px; 
            padding: 5px 10px; 
            border-radius: 20px;
            display: inline-block;
        }
        .pass { background: rgba(35, 134, 54, 0.2); color: #3fb950; border: 1px solid #238636; }
        .fail { background: rgba(218, 54, 51, 0.2); color: #f85149; border: 1px solid #da3633; }

        .log-container {
            margin-top: 30px;
            text-align: left;
            background: #0d1117;
            border: 1px solid #30363d;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>üß™ BitDrop Multi-Level Test Runner</h1>
    <p>Automated verification of 4 core algorithms over 3 degradation levels (Original &rarr; 2x &rarr; 4x &rarr; 8x)</p>

    <div class="original-preview">
        <div class="method-title">Original Input</div>
        <img id="testImage" src="sample.jpg" alt="Test Image" crossOrigin="Anonymous">
        <div id="originalDims" style="margin-top: 5px; color: #8b949e; font-size: 12px;">Loading...</div>
    </div>

    <div class="methods-grid">
        
        <div class="method-card">
            <div class="method-title">Max Pooling</div>
            <canvas id="canvas_max"></canvas>
            <div id="status_max" class="status" style="display:none">Waiting...</div>
        </div>

        <div class="method-card">
            <div class="method-title">Min Pooling</div>
            <canvas id="canvas_min"></canvas>
            <div id="status_min" class="status" style="display:none">Waiting...</div>
        </div>

        <div class="method-card">
            <div class="method-title">Average Pooling</div>
            <canvas id="canvas_avg"></canvas>
            <div id="status_avg" class="status" style="display:none">Waiting...</div>
        </div>

        <div class="method-card">
            <div class="method-title">Median Pooling</div>
            <canvas id="canvas_median"></canvas>
            <div id="status_median" class="status" style="display:none">Waiting...</div>
        </div>

    </div>

    <div id="consoleLog" class="log-container">Initializing Test Suite...<br></div>
</div>

<script>
    const logDiv = document.getElementById('consoleLog');
    const img = document.getElementById('testImage');

    function log(msg, type = 'info') {
        const color = type === 'success' ? '#3fb950' : (type === 'error' ? '#f85149' : '#8b949e');
        logDiv.innerHTML += `<span style="color:${color}">> ${msg}</span><br>`;
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // --- CORE LOGIC: Get Single Pixel based on Method ---
    function getPooledValue(pixels, method) {
        if (method === 'max') {
            return {
                r: Math.max(...pixels.map(p => p.r)),
                g: Math.max(...pixels.map(p => p.g)),
                b: Math.max(...pixels.map(p => p.b))
            };
        } else if (method === 'min') {
            return {
                r: Math.min(...pixels.map(p => p.r)),
                g: Math.min(...pixels.map(p => p.g)),
                b: Math.min(...pixels.map(p => p.b))
            };
        } else if (method === 'average') {
            return {
                r: Math.round(pixels.reduce((s, p) => s + p.r, 0) / pixels.length),
                g: Math.round(pixels.reduce((s, p) => s + p.g, 0) / pixels.length),
                b: Math.round(pixels.reduce((s, p) => s + p.b, 0) / pixels.length)
            };
        } else if (method === 'median') {
            const getMed = (arr) => {
                arr.sort((a, b) => a - b);
                const mid = Math.floor(arr.length / 2);
                return arr.length % 2 ? arr[mid] : Math.round((arr[mid-1] + arr[mid])/2);
            };
            return {
                r: getMed(pixels.map(p => p.r)),
                g: getMed(pixels.map(p => p.g)),
                b: getMed(pixels.map(p => p.b))
            };
        }
    }

    // --- PROCESSING FUNCTION: Runs 1 Iteration ---
    function runDownsampleIteration(sourceCtx, w, h, method) {
        const factor = 2; // Always 2x per level
        const newW = Math.floor(w / factor);
        const newH = Math.floor(h / factor);

        // Create new canvas for this iteration
        const outCanvas = document.createElement('canvas');
        outCanvas.width = newW;
        outCanvas.height = newH;
        const outCtx = outCanvas.getContext('2d');

        const srcData = sourceCtx.getImageData(0, 0, w, h).data;
        const newData = outCtx.createImageData(newW, newH);

        for (let y = 0; y < newH; y++) {
            for (let x = 0; x < newW; x++) {
                const pixels = [];
                for (let dy = 0; dy < factor; dy++) {
                    for (let dx = 0; dx < factor; dx++) {
                        // Clamp to bounds
                        const sx = Math.min(x * factor + dx, w - 1);
                        const sy = Math.min(y * factor + dy, h - 1);
                        const idx = (sy * w + sx) * 4;
                        pixels.push({
                            r: srcData[idx],
                            g: srcData[idx+1],
                            b: srcData[idx+2]
                        });
                    }
                }

                const val = getPooledValue(pixels, method);
                const idx = (y * newW + x) * 4;
                newData.data[idx] = val.r;
                newData.data[idx+1] = val.g;
                newData.data[idx+2] = val.b;
                newData.data[idx+3] = 255;
            }
        }
        outCtx.putImageData(newData, 0, 0);
        return { canvas: outCanvas, ctx: outCtx, w: newW, h: newH };
    }

    // --- MAIN TEST RUNNER ---
    function runTestForMethod(method, levels) {
        const statusEl = document.getElementById(`status_${method === 'average' ? 'avg' : method}`);
        const finalCanvas = document.getElementById(`canvas_${method === 'average' ? 'avg' : method}`);
        
        try {
            // Initial State: Load from Original Image
            const tempC = document.createElement('canvas');
            tempC.width = img.naturalWidth;
            tempC.height = img.naturalHeight;
            const tempCtx = tempC.getContext('2d');
            tempCtx.drawImage(img, 0, 0);

            let currentCtx = tempCtx;
            let currentW = img.naturalWidth;
            let currentH = img.naturalHeight;

            // LOOP: Degrade 3 Times (2x -> 4x -> 8x)
            for (let i = 1; i <= levels; i++) {
                const res = runDownsampleIteration(currentCtx, currentW, currentH, method);
                currentCtx = res.ctx;
                currentW = res.w;
                currentH = res.h;
            }

            // Display Final Result
            finalCanvas.width = currentW;
            finalCanvas.height = currentH;
            const finalCtx = finalCanvas.getContext('2d');
            finalCtx.drawImage(currentCtx.canvas, 0, 0);

            // Validate Size (Should be approx W / 2^3)
            const expectedW = Math.floor(img.naturalWidth / Math.pow(2, levels));
            if (Math.abs(currentW - expectedW) <= 2) { // Allow +/- 2px error
                statusEl.innerHTML = `PASS (Size: ${currentW}x${currentH})`;
                statusEl.className = "status pass";
                log(`[${method.toUpperCase()}] Level 3 Complete. Final Size: ${currentW}x${currentH} ‚úÖ`, "success");
            } else {
                statusEl.innerHTML = `FAIL (Size: ${currentW})`;
                statusEl.className = "status fail";
                log(`[${method.toUpperCase()}] Size mismatch. Expected ${expectedW}, got ${currentW} ‚ùå`, "error");
            }
            statusEl.style.display = "inline-block";

        } catch (e) {
            console.error(e);
            statusEl.innerHTML = "ERROR";
            statusEl.className = "status fail";
            statusEl.style.display = "inline-block";
            log(`[${method.toUpperCase()}] Crashed: ${e.message}`, "error");
        }
    }

    img.onload = () => {
        const w = img.naturalWidth;
        const h = img.naturalHeight;
        document.getElementById('originalDims').innerText = `Dimensions: ${w}x${h}px`;
        log(`Image Loaded: ${w}x${h}px`, "success");
        log("Starting 3-Level Degradation Tests...", "info");

        // Run all 4 methods with small delays to update UI
        setTimeout(() => runTestForMethod('max', 3), 100);
        setTimeout(() => runTestForMethod('min', 3), 500);
        setTimeout(() => runTestForMethod('average', 3), 1000);
        setTimeout(() => runTestForMethod('median', 3), 1500);
    };

    img.onerror = () => {
        log("‚ùå Error: 'sample.jpg' not found.", "error");
    };

</script>
</body>
</html>